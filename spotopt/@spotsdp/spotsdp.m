classdef spotsdp
    properties 
        % Developer's Notes about Internal Representation:
        % 
        % The program consists of a collection of variable dimensions:
        % 
        % name -- Character prefix for variables from the program.
        %
        %
        % posNum  -- 1-by-1 Positive integer (number of non-negative variables).
        % freeNum -- 1-by-1 Positive integer (number of non-negative variables).
        % psdDim -- Npsd-by-1 array of positive integers.  Each represents
        %                     psdDim(i)-by-psdDim(i) dim. variable.
        % lorDim -- Nlor-by-1 array of positive integers.  Size of
        %                     Lorentz cones (n indicates x(1)^2 >=
        %                     sum_i=2^n x(i)^2 )
        % rlorDim -- Nrlor-by-1 array of positive integers, similar
        %                     for rotated Lorentz cones.
        %
        % Variables are named @psdi, @lori, @posi @rlri, where @ is
        % replaced by 'name' and 'i' is a running counter.
        %
        %
        %
        name = '@';
        
        posNum  = 0;
        freeNum = 0;
        psdDim  = [];
        lorDim  = [];
        rlorDim = [];
        
        equations = [];
    end

    methods (Static)
        function n = psdDimToNo(d)
            n=(d+1).*d/2;
        end
    end
    
    methods ( Access = private )        
%  These private functions define the names of variables
%  generated by the program.

        function nm = freeName(pr)
            nm = [pr.name 'fr'];
        end
        function nm = posName(pr)
            nm = [pr.name 'pos'];
        end
        function nm = psdName(pr)
            nm = [pr.name 'psd'];
        end
        function nm = lorName(pr)
            nm = [pr.name 'lor'];
        end
        function nm = rlorName(pr)
            nm = [pr.name 'rlr'];
        end
        function nm = dualName(pr)
            nm = [pr.name 'dl'];
        end

        

        

        
        function flag = legalEq(pr,eq)
            if ~isa(eq,'msspoly')
                flag = 0;
            else
                flag = realLinearInDec(pr,eq);
            end
        end
    end
    methods
        
        function pr=spotsdp(name)
        % pr=spotsdp(prefix)
        %
        % prefix -- Scalar character, legal name for msspoly.
        %
        % Returns:
        % pr   -- New program, decision variables begin with
        %         the character prefix.
            if nargin > 0
                if ~ischar(name) || length(name) > 1
                    error('Program name must be a scalar character.');
                else
                    msspoly(name);
                end
                pr.name = name;
            end
        end
        
        function flag = realLinearInDec(pr,exp)
            [x,pow,Coeff] = decomp(exp);
            [~,xid] = isfree(x);
            [~,vid] = isfree(pr.variables);
            flag = ~(any(mss_match(vid,xid) == 0) | ...
                     any(pow(:) > 1) | ...
                     any(imag(Coeff(:)) ~= 0));
        end
        
        %  Generate variables of a given type.        
        function f = freeVariables(pr)
            f = msspoly(pr.freeName,pr.numFree);
        end
        function p = posVariables(pr)
            p = msspoly(pr.posName,pr.numPos);
        end
        function l = lorVariables(pr)
            l = msspoly(pr.lorName,pr.numLor);
        end
        function r = rlorVariables(pr)
            r = msspoly(pr.rlorName,pr.numRLor);
        end
        function p = psdVariables(pr)
            p = msspoly(pr.psdName,pr.numPSD);
        end
        
        function v = variables(pr)
        % v = variables(pr)
        % v -- msspoly column of primal variables for the program pr.
            v = [ pr.freeVariables
                  pr.posVariables
                  pr.lorVariables
                  pr.rlorVariables
                  pr.psdVariables];
        end
        
        function y = dualVariables(pr)
            y = msspoly(pr.dualName,pr.numEq);
        end

        function n = numPos(pr)
            n = pr.posNum;
        end
        function n = numFree(pr)
            n = pr.freeNum;
        end
        function n = numPSD(pr)
            n = sum(spotsdp.psdDimToNo(pr.psdDim));
        end
        function n = numLor(pr)
            n = sum(pr.lorDim);
        end
        function n = numRLor(pr)
            n = sum(pr.rlorDim);
        end
        function m = numEq(pr)
            m = length(pr.equations);
        end
        
        function [pr,Q] = newPSD(pr,dim)
            if ~spot_hasSize(dim,[1 1]) || ~spot_isIntGE(dim,1)
                error('Dimension must be scalar positive integer.');
            end
            n = spotsdp.psdDimToNo(dim);
            
            Q = mss_v2s(msspoly(pr.psdName,[n pr.numPSD]));
            
            pr.psdDim = [pr.psdDim dim];
        end
        
        function [pr,Qs] = newBlkPSD(pr,dim)
            if ~spot_hasSize(dim,[1 2]) || ~spot_isIntGE(dim,1)
                error('Dimension must be 1x2 positive integer.');
            end
            
            n = spotsdp.psdDimToNo(dim(1));
            
            Qs = reshape(msspoly(pr.psdName,[n*dim(2) pr.numPSD]),n,dim(2));
            pr.psdDim = [pr.psdDim dim(1)*ones(1,dim(2))];
        end
        
        function [pr,p] = newPos(pr,dim)
            if ~spot_hasSize(dim,[1 1]) || ~spot_isIntGE(dim,1)
                error('Dimension must be scalar positive integer.');
            end
            
            p = msspoly(pr.posName,[dim pr.numPos]);
            
            pr.posNum = pr.posNum+dim;
        end
        
        function [pr,f] = newFree(pr,dim)
            if spot_hasSize(dim,[1 1])
                dim = [ dim 1];
            end
            if ~spot_hasSize(dim,[1 2]) || ~spot_isIntGE(dim,1)
                error('Dimension must be 1-by-1 or 1-by-2 positive integer.');
            end
            
            f = reshape(msspoly(pr.freeName,[prod(dim) pr.numFree]),dim);
            
            pr.freeNum = pr.freeNum+prod(dim);
        end
        
        function [pr,l] = newLor(pr,dim)
            if spot_hasSize(dim,[1 1]), dim = [dim 1]; end
            if ~spot_hasSize(dim,[1 2]) || ~spot_isIntGE(dim,1)
                error('Dimension must be 1x2 positive integer.');
            end
            
            l = reshape(msspoly(pr.lorName,[prod(dim) pr.numLor]),dim(1),dim(2));
            
            pr.lorDim = [pr.lorDim dim(1)*ones(1,dim(2))];
        end
        
        function [pr,r] = newRLor(pr,dim)
            if spot_hasSize(dim,[1 1]), dim = [dim 1]; end
            if ~spot_hasSize(dim,[1 2]) ...
                    || ~spot_isIntGE(dim(2),1)...
                    || ~spot_isIntGE(dim(1),2)
                error(['Dimension must be 1x2, first entry >= 2, ' ...
                       'second entry >= 1.']);
            end
            
            r = reshape(msspoly(pr.rlorName,[prod(dim) pr.numRLor]),dim(1),dim(2));
            
            pr.rlorDim = [pr.rlorDim dim(1)*ones(1,dim(2))];
        end
        
        function [pr,y] = withEqs(pr,eq)
            if ~pr.legalEq(eq)
                error(['Equations must be an msspoly linear in ' ...
                       'decision parameters.']);
            end
            eq = eq(:);
            
            y = msspoly(pr.dualName,[length(eq) pr.numEq]);
            pr.equations = [pr.equations ; eq];
        end
         
        %-- 
        function [pr,s,y] = withPos(pr,exp)
            if ~isa(exp,'msspoly')
                error('Argument must be a column of msspoly expressions.');
            end
            exp = exp(:);
            
            [pr,s] = pr.newPos(length(exp));
            [pr,y] = pr.withEqs(exp - s);
        end
        
        function [pr,Q,y] = withPSD(pr,exp)
            if ~isa(exp,'msspoly') || size(exp,1) ~= size(exp,2)
                error('Argument must be a square msspoly.');
            end
            
            if size(exp,1) == 1
                [pr,l,y] = pr.withPos(pr,exp);
            else
                [pr,Q] = pr.newPSD(size(exp,1));
                [pr,y] = pr.withEqs(mss_s2v(exp-Q));
            end
        end
        
        function [pr,Qs,y] = withBlkPSD(pr,exp)
            if ~isa(exp,'msspoly')
                error('Argument must be an msspoly.');
            end
            if ~spotsdp.validSymMtxVec(size(exp,1))
                error('Argument wrong size.');
            end
            
            if size(exp,1) == 1
                [pr,l,y] = pr.withPos(pr,exp);
            else
                [pr,Qs] = pr.newBlkPSD(size(exp));
                [pr,y] = pr.withEqs(exp-Q);
            end
        end
        
        function [pr,l,y] = withLor(pr,exp)
            if ~isa(exp,'msspoly')
                error('Argument must be an msspoly.');
            end
            
            if size(exp,1) == 1
                [pr,l,y] = pr.withPos(pr,exp);
            else
                [pr,l] = pr.newLor(size(exp));
                [pr,y] = pr.withEqs(exp(:)-l(:));
            end
        end
        
        function [pr,l,y] = withRLor(pr,exp)
            if ~isa(exp,'msspoly')
                error('Argument must be an msspoly.');
            end
            
            if size(exp,1) == 2
                [pr,l,y] = pr.withPos(pr,exp);
            else
                [pr,l] = pr.newRLor(size(exp));
                [pr,y] = pr.withEqs(exp(:)-l(:));
            end
        end
        
    end
end