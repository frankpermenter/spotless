classdef spotsdp
    properties
        % Developer's Notes about Internal Representation:
        % 
        % The program consists of a collection of variable dimensions:
        % 
        % name -- Character prefix for variables from the program.
        %
        %
        % posNum  -- 1-by-1 Positive integer (number of non-negative variables).
        % freeNum -- 1-by-1 Positive integer (number of non-negative variables).
        % psdDim -- Npsd-by-1 array of positive integers.  Each represents
        %                     psdDim(i)-by-psdDim(i) dim. variable.
        % lorDim -- Nlor-by-1 array of positive integers.  Size of
        %                     Lorentz cones (n indicates x(1)^2 >=
        %                     sum_i=2^n x(i)^2 )
        % rlorDim -- Nrlor-by-1 array of positive integers, similar
        %                     for rotated Lorentz cones.
        %
        % Variables are named @psdi, @lori, @posi @rlri, where @ is
        % replaced by 'name' and 'i' is a running counter.
        %
        %
        %
        name = '@';
        
        posNum  = 0;
        freeNum = 0;
        psdDim  = [];
        lorDim  = [];
        rlorDim = [];
        
        psdCstr = [];
        psdCstrDim = [];
        
        lorCstr = [];
        lorCstrDim = [];
        rlorCstr = [];
        rlorCstrDim = [];
        posCnst = [];
        
        equations = [];
    end

    methods (Static)
        function n = psdDimToNo(d)
            n=(d+1).*d/2;
        end
        
        function [d,v] = psdNoToDim(n)
        %
        %  0 = d^2 + d - 2n
        %  (sqrt(1 + 8n) - 1)/2
        %
            d=round((sqrt(1+8*n)-1)/2);
            if spotsdp.psdDimToNo(d) ~= n
                d = NaN;
                v = 0;
            else
                v = 1;
            end
        end

    end

    
    methods ( Access = private )        
%  These private functions define the names of variables
%  generated by the program.

        function nm = freeName(pr)
            nm = [pr.name 'fr'];
        end
        function nm = posName(pr)
            nm = [pr.name 'pos'];
        end
        function nm = psdName(pr)
            nm = [pr.name 'psd'];
        end
        function nm = lorName(pr)
            nm = [pr.name 'lor'];
        end
        function nm = rlorName(pr)
            nm = [pr.name 'rlr'];
        end

        function flag = legalEq(pr,eq)
            if ~isa(eq,'msspoly')
                flag = 0;
            else
                flag = realLinearInDec(pr,eq);
            end
        end
    end
    
    % ---- General modeling methods (i.e. posing inequalities)
    methods
        function pr=spotsdp(name)
        % pr=spotsdp(prefix)
        %
        % prefix -- Scalar character, legal name for msspoly.
        %
        % Returns:
        % pr   -- New program, decision variables begin with
        %         the character prefix.
        %
        %
        % spotsdp objects model SDP/SOCP/LP cone programs.
        %
        %    The feasible set of these programs is represented in a
        %    mixture of standard primal and standard dual form:
        %
        %    (F)  x in K1,  y free,
        %         A1.x + A2.y = b,
        %         D1.x + D2.y + e in K2,
        %
        %    where K1 and K2 are products of the SDP, SOCP and LP
        %    cones of various dimensions.
        %
        %    After the feasible set has been constructed, an
        %    optimization problem can be solved via prg.optimze():
        %   
        %    minimize c'x + f'y  subj. to. (F)
        %
        %    Solution of these problems by primal dual solvers such
        %    as SeDuMi or SDPT3 requires converting the problem to
        %    standard primal or dual form.  The choice of which
        %    conversion to apply can be forced as an optimizatio parameter.
        %
        %
        %
            if nargin > 0
                if ~ischar(name) || length(name) > 1
                    error('Program name must be a scalar character.');
                else
                    msspoly(name);
                end
                pr.name = name;
            end
        end
        
        function flag = realLinearInDec(pr,exp)
            [x,pow,Coeff] = decomp(exp);
            [~,xid] = isfree(x);
            [~,vid] = isfree(pr.variables);
            flag = ~(any(mss_match(vid,xid) == 0) | ...
                     any(pow(:) > 1) | ...
                     any(imag(Coeff(:)) ~= 0));
        end
        
        %  Generate variables of a given type.        
        function f = freeVariables(pr)
            f = msspoly(pr.freeName,pr.numFree);
        end
        function p = posVariables(pr)
            p = msspoly(pr.posName,pr.numPos);
        end
        function [l,dim] = lorVariables(pr)
            l = msspoly(pr.lorName,pr.numLor);
            dim = pr.lorDim;
        end
        
        function [r,dim] = rlorVariables(pr)
            r = msspoly(pr.rlorName,pr.numRLor);
            dim = pr.rlorDim;
        end
        
        function [p,dim] = psdVariables(pr)
            p = msspoly(pr.psdName,pr.numPSD);
            dim = pr.psdDim;
        end
        
        function p = psdVariable(pr,i)
            if ~spot_isIntGE(i,1) || i > length(pr.psdDim)
                error(['PSD variable ' num2str(i) ' does not exist.']);
            end
            i0 = sum(spotsdp.psdDimToNo(pr.psdDim(1:i-1)));
            n = spotsdp.psdDimToNo(pr.psdDim(i));
            p = mss_v2s(msspoly(pr.psdName,[n,i0]));
        end
        
        function [pcstr,dim] = posConstraints(pr)
            pcstr = pr.posCnst;
            dim = length(pcstr);
        end
        
        function [lcstr,dim] = lorConstraints(pr)
            lcstr = pr.lorCstr;
            dim = pr.lorCstrDim;
        end
        
        function [rcstr,dim] = rlorConstraints(pr)
            rcstr = pr.rlorCstr;
            dim = pr.rlorCstrDim;
        end
        
        
        function [psdcstr,dim] = psdConstraints(pr)
            dim = pr.psdCstrDim;
            psdcstr = pr.psdCstr;
        end
        
        function [scstr,dim] = psdConstraint(pr,i)
            if ~spot_hasSize(i,[1 1])  || ~spot_isIntGE(i,1) || ...
                    i > length(pr.psdCstrDim)
                error('Bad Index.');
            end
            
            i0 = sum(spotsdp.psdDimToNo(pr.psdCstrDim(1:i-1)));
            dim = pr.psdCstrDim(i);
            scstr = pr.psdCstr(i0+(1:spotsdp.psdDimToNo(dim)));
        end

        
        function v = variables(pr)
        % v = variables(pr)
        % v -- msspoly column of primal variables for the program pr.
            v = [ pr.freeVariables
                  pr.posVariables
                  pr.lorVariables
                  pr.rlorVariables
                  pr.psdVariables];
        end
        
        function n = numPos(pr)
            n = pr.posNum;
        end
        function n = numFree(pr)
            n = pr.freeNum;
        end
        function n = numPSD(pr)
            n = sum(spotsdp.psdDimToNo(pr.psdDim));
        end
        function n = numLor(pr)
            n = sum(pr.lorDim);
        end
        function n = numRLor(pr)
            n = sum(pr.rlorDim);
        end
        
        function m = numEq(pr)
            m = length(pr.equations);
        end
        
        
        function [pr,Q] = newPSD(pr,dim)
            if ~spot_hasSize(dim,[1 1]) || ~spot_isIntGE(dim,1)
                error('Dimension must be scalar positive integer.');
            end
            n = spotsdp.psdDimToNo(dim);
            
            Q = mss_v2s(msspoly(pr.psdName,[n pr.numPSD]));
            
            pr.psdDim = [pr.psdDim dim];
        end
        
        function [pr,Q] = newPSDs(pr,dim)
            if isempty(dim), Q = []; return; end

            if size(dim,1) ~= 1 || ~spot_isIntGE(dim,1)
                error('Dimension must be scalar positive integers.');
            end
            
            n = sum(spotsdp.psdDimToNo(dim));
            
            Q = msspoly(pr.psdName,[n pr.numPSD]);
            
            pr.psdDim = [ pr.psdDim dim ];
        end
        
        function [pr,Qs] = newBlkPSD(pr,dim)
            if ~spot_hasSize(dim,[1 2]) || ~spot_isIntGE(dim,1)
                error('Dimension must be 1x2 positive integer.');
            end
            
            n = spotsdp.psdDimToNo(dim(1));
            
            Qs = reshape(msspoly(pr.psdName,[n*dim(2) pr.numPSD]),n,dim(2));
            pr.psdDim = [pr.psdDim dim(1)*ones(1,dim(2))];
        end
        
        function [pr,p] = newPos(pr,dim)
            if ~spot_hasSize(dim,[1 1]) || ~spot_isIntGE(dim,0)
                error('Dimension must be scalar positive integer.');
            end
            
            if dim == 0, p = [];
            else
                p = msspoly(pr.posName,[dim pr.numPos]);
                pr.posNum = pr.posNum+dim;
            end
        end
        
        function [pr,f] = newFree(pr,dim)
            if spot_hasSize(dim,[1 1])
                dim = [ dim 1];
            end
            if ~spot_hasSize(dim,[1 2]) || ~spot_isIntGE(dim,1)
                error('Dimension must be 1-by-1 or 1-by-2 positive integer.');
            end
            
            f = reshape(msspoly(pr.freeName,[prod(dim) pr.numFree]),dim);
            
            pr.freeNum = pr.freeNum+prod(dim);
        end
        
        function [pr,l] = newLor(pr,dim)
            if spot_hasSize(dim,[1 1]), dim = [dim 1]; end
            if ~spot_hasSize(dim,[1 2]) || ~spot_isIntGE(dim,1)
                error('Dimension must be 1x2 positive integer.');
            end
            
            l = reshape(msspoly(pr.lorName,[prod(dim) pr.numLor]),dim(1),dim(2));
            
            pr.lorDim = [pr.lorDim dim(1)*ones(1,dim(2))];
        end
        
        function [pr,l] = newLors(pr,dim)
            if isempty(dim), l = []; return; end
            
            if size(dim,1) ~= 1 || ~spot_isIntGE(dim,1)
                error('Dimension must be 1xn positive integer.');
            end
            
            l = msspoly(pr.lorName,[sum(dim) pr.numLor]);
            pr.lorDim = [ pr.lorDim dim ];
        end

        function [pr,r] = newRLor(pr,dim)
            if spot_hasSize(dim,[1 1]), dim = [dim 1]; end
            if ~spot_hasSize(dim,[1 2]) || ~spot_isIntGE(dim,1)
                error('Dimension must be 1x2 positive integer.');
            end
            
            r = reshape(msspoly(pr.rlorName,[prod(dim) pr.numRLor]),dim(1),dim(2));
            
            pr.rlorDim = [pr.rlorDim dim(1)*ones(1,dim(2))];
        end
        
        function [pr,r] = newRLors(pr,dim)
            if isempty(dim), r = []; return; end
            
            if size(dim,1) ~= 1 || ~spot_isIntGE(dim,2)
                error('Dimension must be 1xn integer, >= 2.');
            end
            
            r = msspoly(pr.rlorName,[sum(dim) pr.numRLor]);
            pr.rlorDim = [ pr.rlorDim dim ];
        end
        
        function [pr] = withEqs(pr,eq)
            if ~pr.legalEq(eq)
                error(['Equations must be an msspoly linear in ' ...
                       'decision parameters.']);
            end
            eq = eq(:);
            
            pr.equations = [pr.equations ; eq];
        end
         
        %-- 
        function [pr] = withPos(pr,exp)
            if ~isa(exp,'msspoly')
                error('Argument must be a column of msspoly expressions.');
            end
            exp = exp(:);
            
            pr.posCnst = [pr.posCnst ; exp];
        end
        
        function [pr] = withPSD(pr,exp,dim)
            if ~isa(exp,'msspoly') 
                error('Argument must be an msspoly.');
            end
            
            % It is non-square.
            if size(exp,1) ~= size(exp,2) || nargin > 2,
                if size(exp,2) > 1,
                    error('Argument must be square or a column.');
                end
                if nargin < 2,
                    error(['For column argument, dim must be specified']); 
                end
                
                if sum(spotsdp.psdDimToNo(dim)) ~= length(exp)
                    error(['Dimension does not agree with length of ' ...
                           'column argument.']);
                end

                pr.psdCstr = [pr.psdCstr ; exp ];
                pr.psdCstrDim = [ pr.psdCstrDim dim];
            else % Non-square and dim not specified.
                dim = size(exp,1);
                exp = mss_s2v(exp);
                pr = pr.withPSD(exp,dim);
            end
        end
        
        function [pr] = withBlkPSD(pr,exp)
            if ~isa(exp,'msspoly')
                error('Argument must be an msspoly.');
            end
            [dim,v] = spotsdp.psdNoToDim(size(exp,1));
            if ~v
                error('Argument wrong size.');
            end
            
            pr = pr.withPSD(exp(:),dim*ones(1,size(exp,2)));
        end
        
        function [pr] = withLor(pr,exp,dim)
            if nargin > 2 && isempty(dim),
                return;
            end
            if ~isa(exp,'msspoly')
                error('Argument must be an msspoly.');
            end
            
            if nargin == 2,
                pr = pr.withLor(exp(:),size(exp,1)*ones(1,size(exp,2)));
            else
                if size(dim,1) ~= 1 || ~spot_isIntGE(dim,1), 
                    error('Dimensions must be row of positive integers.');
                end
                
                if sum(dim) ~= length(exp),
                    error(['Dimensions and expression length do not match.']); 
                end
                pr.lorCstr = [pr.lorCstr ; exp];
                pr.lorCstrDim = [ pr.lorCstrDim dim ];
            end
        end
        
        function [pr] = withRLor(pr,exp,dim)
            if nargin > 2 && isempty(dim),
                return;
            end
            if ~isa(exp,'msspoly')
                error('Argument must be an msspoly.');
            end
            
            if nargin == 2,
                pr = pr.withLor(exp(:),size(exp,1)*ones(1,size(exp,2)));
            else
                if size(dim,1) ~= 1 || ~spot_isIntGE(dim,2), 
                    error('Dimensions must be row of integers, >= 2.');
                end
                
                if sum(dim) ~= length(exp),
                    error(['Dimensions and expression length do not match.']); 
                end
                
                pr.rlorCstr = [pr.rlorCstr ; exp];
                pr.rlorCstrDim = [ pr.rlorCstrDim dim ];
            end
        end
            
    end
    
    methods
        function f = isStandardDualForm(prg)
            f = isempty(prg.equations) && ...
                prg.numPos == 0 && ...
                prg.numPSD == 0 && ...
                prg.numLor == 0 && ...
                prg.numRLor == 0;
        end
        
% Transform programs into standard forms (maybe move this out?)

        function [prgout,G,h] = standardDual(prg)
        %
        %  [spPrg,G,h] = standardDual(prg)
        %
        %  Converts a program into the standard dual form.
        %
        %  Conic variables are replaced by new free variables.
        %
        %  Then, a lower dimensional parameterization:
        %
        %  [ x; y] = Gz + h
        %
        %  is found with [A1 A2] h = b, [A1 A2] G = 0.
        %
        %

            function prgout = moveConstraints(prgout,prg,free)
                if ~isempty(prg.posCnst)
                    prgout = prgout.withPos(subs(prg.posCnst,prg.variables,free));
                end
            end
            
            
            function prgout = removeConic(prg)
                prgout = spotsdp(prg.name);
                [prgout,free] = prgout.newFree(length(prg.variables));
            
                if prg.numPos > 0
                    mtch = match(prg.variables,prg.posVariables);
                    prgout = prgout.withPos(free(mtch));
                end
                
                if prg.numLor > 0
                    error('Did not support Lorentz cone yet.');
                end
                if prg.numRLor > 0
                    error('Did not support Rotated Lorentz cone yet.');
                end
                
                prgout = moveConstraints(prgout,prg,free);
                prgout = prgout.withEqs(subs(prg.equations,prg.variables,free));
            end
            
            function prgout = removeEquality(prg)
            % Now resolve equality constraints.
                if length(prg.equations) == 0,
                    prgout = prg;
                    G = speye(prg.numFree);
                    h = sparse([],[],[],prg.numFree,1);
                    return;
                end
                
                prgout = spotsdp(prg.name);

                [A,b] = spot_decomp_linear(prg.equations,prg.variables);
            
                % TODO: Return to this setting to preserve sparsity.
                
                h = A\b;
                
                [Q,R] = qr(A');
                n = max(find(sum(abs(R),2)));
                G = Q(:,n+1:end); % New basis

                [prgout,z] = prgout.newFree(size(G,2));
                
                prgout = moveConstraints(prgout,prg,G*z+h);
            end
            
            prgout = removeConic(prg);
            prgout = removeEquality(prgout);
          
        end
    end
    

end