classdef spotsdp
    properties 
        % Developer's Notes about Internal Representation:
        % 
        % The program consists of a collection of variable dimensions:
        % 
        % name -- Character prefix for variables from the program.
        %
        %
        % posNum  -- 1-by-1 Positive integer (number of non-negative variables).
        % freeNum -- 1-by-1 Positive integer (number of non-negative variables).
        % psdDim -- Npsd-by-1 array of positive integers.  Each represents
        %                     psdDim(i)-by-psdDim(i) dim. variable.
        % lorDim -- Nlor-by-1 array of positive integers.  Size of
        %                     Lorentz cones (n indicates x(1)^2 >=
        %                     sum_i=2^n x(i)^2 )
        % rlorDim -- Nrlor-by-1 array of positive integers, similar
        %                     for rotated Lorentz cones.
        %
        % Variables are named @psdi, @lori, @posi @rlri, where @ is
        % replaced by 'name' and 'i' is a running counter.
        %
        %
        %
        name = '@';
        
        posNum  = 0;
        freeNum = 0;
        psdDim  = [];
        lorDim  = [];
        rlorDim = [];
        
        psdCnst = {};
        lorCnst = {};
        posCnst = [];
        
        equations = [];
    end

    methods (Static)
        function n = psdDimToNo(d)
            n=(d+1).*d/2;
        end
        
        function [d,v] = psdNoToDim(n)
        %
        %  0 = d^2 + d - 2n
        %  (sqrt(1 + 8n) - 1)/2
        %
            d=round((sqrt(1+8*n)-1)/2);
            if spotsdp.psdDimToNo(d) ~= n
                d = NaN;
                v = 0;
            else
                v = 1;
            end
        end

    end

    
    methods ( Access = private )        
%  These private functions define the names of variables
%  generated by the program.

        function nm = freeName(pr)
            nm = [pr.name 'fr'];
        end
        function nm = posName(pr)
            nm = [pr.name 'pos'];
        end
        function nm = psdName(pr)
            nm = [pr.name 'psd'];
        end
        function nm = lorName(pr)
            nm = [pr.name 'lor'];
        end
        function nm = rlorName(pr)
            nm = [pr.name 'rlr'];
        end

        function flag = legalEq(pr,eq)
            if ~isa(eq,'msspoly')
                flag = 0;
            else
                flag = realLinearInDec(pr,eq);
            end
        end
    end
    
    % ---- General modeling methods (i.e. posing inequalities)
    methods
        function pr=spotsdp(name)
        % pr=spotsdp(prefix)
        %
        % prefix -- Scalar character, legal name for msspoly.
        %
        % Returns:
        % pr   -- New program, decision variables begin with
        %         the character prefix.
        %
        %
        % spotsdp objects model SDP/SOCP/LP cone programs.
        %
        %    The feasible set of these programs is represented in a
        %    mixture of standard primal and standard dual form:
        %
        %    (F)  x in K1,  y free,
        %         A1.x + A2.y = b,
        %         D1.x + D2.y + e in K2,
        %
        %    where K1 and K2 are products of the SDP, SOCP and LP
        %    cones of various dimensions.
        %
        %    After the feasible set has been constructed, an
        %    optimization problem can be solved via prg.optimze():
        %   
        %    minimize c'x + f'y  subj. to. (F)
        %
        %    Solution of these problems by primal dual solvers such
        %    as SeDuMi or SDPT3 requires converting the problem to
        %    standard primal or dual form.  The choice of which
        %    conversion to apply can be forced as an optimizatio parameter.
        %
        %
        %
            if nargin > 0
                if ~ischar(name) || length(name) > 1
                    error('Program name must be a scalar character.');
                else
                    msspoly(name);
                end
                pr.name = name;
            end
        end
        
        function flag = realLinearInDec(pr,exp)
            [x,pow,Coeff] = decomp(exp);
            [~,xid] = isfree(x);
            [~,vid] = isfree(pr.variables);
            flag = ~(any(mss_match(vid,xid) == 0) | ...
                     any(pow(:) > 1) | ...
                     any(imag(Coeff(:)) ~= 0));
        end
        
        %  Generate variables of a given type.        
        function f = freeVariables(pr)
            f = msspoly(pr.freeName,pr.numFree);
        end
        function p = posVariables(pr)
            p = msspoly(pr.posName,pr.numPos);
        end
        function l = lorVariables(pr)
            l = msspoly(pr.lorName,pr.numLor);
        end
        function r = rlorVariables(pr)
            r = msspoly(pr.rlorName,pr.numRLor);
        end
        function p = psdVariables(pr)
            p = msspoly(pr.psdName,pr.numPSD);
        end

        
        function v = variables(pr)
        % v = variables(pr)
        % v -- msspoly column of primal variables for the program pr.
            v = [ pr.freeVariables
                  pr.posVariables
                  pr.lorVariables
                  pr.rlorVariables
                  pr.psdVariables];
        end
        
        function n = numPos(pr)
            n = pr.posNum;
        end
        function n = numFree(pr)
            n = pr.freeNum;
        end
        function n = numPSD(pr)
            n = sum(spotsdp.psdDimToNo(pr.psdDim));
        end
        function n = numLor(pr)
            n = sum(pr.lorDim);
        end
        function n = numRLor(pr)
            n = sum(pr.rlorDim);
        end
        function m = numEq(pr)
            m = length(pr.equations);
        end
        
        function [pr,Q] = newPSD(pr,dim)
            if ~spot_hasSize(dim,[1 1]) || ~spot_isIntGE(dim,1)
                error('Dimension must be scalar positive integer.');
            end
            n = spotsdp.psdDimToNo(dim);
            
            Q = mss_v2s(msspoly(pr.psdName,[n pr.numPSD]));
            
            pr.psdDim = [pr.psdDim dim];
        end
        
        function [pr,Qs] = newBlkPSD(pr,dim)
            if ~spot_hasSize(dim,[1 2]) || ~spot_isIntGE(dim,1)
                error('Dimension must be 1x2 positive integer.');
            end
            
            n = spotsdp.psdDimToNo(dim(1));
            
            Qs = reshape(msspoly(pr.psdName,[n*dim(2) pr.numPSD]),n,dim(2));
            pr.psdDim = [pr.psdDim dim(1)*ones(1,dim(2))];
        end
        
        function [pr,p] = newPos(pr,dim)
            if ~spot_hasSize(dim,[1 1]) || ~spot_isIntGE(dim,1)
                error('Dimension must be scalar positive integer.');
            end
            
            p = msspoly(pr.posName,[dim pr.numPos]);
            
            pr.posNum = pr.posNum+dim;
        end
        
        function [pr,f] = newFree(pr,dim)
            if spot_hasSize(dim,[1 1])
                dim = [ dim 1];
            end
            if ~spot_hasSize(dim,[1 2]) || ~spot_isIntGE(dim,1)
                error('Dimension must be 1-by-1 or 1-by-2 positive integer.');
            end
            
            f = reshape(msspoly(pr.freeName,[prod(dim) pr.numFree]),dim);
            
            pr.freeNum = pr.freeNum+prod(dim);
        end
        
        function [pr,l] = newLor(pr,dim)
            if spot_hasSize(dim,[1 1]), dim = [dim 1]; end
            if ~spot_hasSize(dim,[1 2]) || ~spot_isIntGE(dim,1)
                error('Dimension must be 1x2 positive integer.');
            end
            
            l = reshape(msspoly(pr.lorName,[prod(dim) pr.numLor]),dim(1),dim(2));
            
            pr.lorDim = [pr.lorDim dim(1)*ones(1,dim(2))];
        end
        
        function [pr,r] = newRLor(pr,dim)
            if spot_hasSize(dim,[1 1]), dim = [dim 1]; end
            if ~spot_hasSize(dim,[1 2]) || ~spot_isIntGE(dim,1)
                error('Dimension must be 1x2 positive integer.');
            end
            
            r = reshape(msspoly(pr.rlorName,[prod(dim) pr.numRLor]),dim(1),dim(2));
            
            pr.rlorDim = [pr.rlorDim dim(1)*ones(1,dim(2))];
        end
        
        function [pr] = withEqs(pr,eq)
            if ~pr.legalEq(eq)
                error(['Equations must be an msspoly linear in ' ...
                       'decision parameters.']);
            end
            eq = eq(:);
            
            pr.equations = [pr.equations ; eq];
        end
         
        %-- 
        function [pr] = withPos(pr,exp)
            if ~isa(exp,'msspoly')
                error('Argument must be a column of msspoly expressions.');
            end
            exp = exp(:);
            
            pr.posCnst = [pr.posCnst ; exp];
        end
        
        function [pr] = withPSD(pr,exp)
            if ~isa(exp,'msspoly') || size(exp,1) ~= size(exp,2)
                error('Argument must be a square msspoly.');
            end
            
            if size(exp,1) == 1
                [pr,l] = pr.withPos(pr,exp);
            else
                exp = mss_s2v(exp);
                pr.psdCnst{end+1} = exp;
            end
        end
        
        function [pr] = withBlkPSD(pr,exp)
            if ~isa(exp,'msspoly')
                error('Argument must be an msspoly.');
            end
            [~,v] = spotsdp.psdNoToDim(size(exp,1));
            if ~v
                error('Argument wrong size.');
            end
            
            if size(exp,1) == 1
                pr = pr.withPos(pr,exp);
            else
                pr.psdCnst{end+1} = exp;
            end
        end
        
        function [pr] = withLor(pr,exp)
            if ~isa(exp,'msspoly')
                error('Argument must be an msspoly.');
            end
            
            if size(exp,1) == 1
                [pr] = pr.withPos(exp);
            else
                pr.lorCnst{end+1} = exp;
            end
        end
    end
    
    
    % ---- Methods for dealing with Dual Form.
    
    methods (Static)
        function f = isStandardDualForm(prg)
            f = isa(prg,'spotsdp') && ...
                isempty(prg.equations) && ...
                prg.numPos == 0 && ...
                prg.numPSD == 0 && ...
                prg.numLor == 0;
        end
    end
    
    methods
% Transform programs into standard forms (maybe move this out?)
        function [spPrg,G,h] = standardPrimalWithFree(prg)
        %
        %  [spPrg,G,h] = standardPrimalWithFree(prg)
        %
        %  Converts a program into the standard primal with free
        %  variables form via the introduction of slack variables.
        %
        %  The matrices G,h are constructed so that
        %
        %  prg.variables = G*spPrg.variables + h.
        %
            spPrg = prg;
            
            if length(spPrg.posCnst) > 0
                [spPrg,slack] = spPrg.newPos(length(spPrg.posCnst));
                spPrg = spPrg.withEqs(spPrg.posCnst - slack);
                spPrg.posCnst = {};
            end
            
            for i = 1:length(spPrg.psdCnst)
                cnst = spPrg.psdCnst{i};

                [spPrg,slack] = spPrg.newBlkPSD([spotsdp.psdNoToDim(size(cnst,1)) size(cnst,2)]);
                spPrg = spPrg.withEqs(cnst - slack);
            end            
            spPrg.psdCnst = {};
            
            for i = 1:length(spPrg.lorCnst)
                cnst = spPrg.lorCnst{i};

                [spPrg,slack] = spPrg.newLor(size(cnst,1));
                spPrg = spPrg.withEqs(cnst - slack);
            end            
            spPrg.lorCnst = {};
            
            h = zeros(size(prg.variables));
            
            [var,pow,Coeff] = decomp(spPrg.variables);

            mtch = match(var,prg.variables);
            
            G = Coeff(:,mtch)';
            
        end


        function [prgout,G,h] = standardDual(prg)
        %
        %  [spPrg,G,h] = standardDual(prg)
        %
        %  Converts a program into the standard dual form.
        %
        %  Conic variables are replaced by new free variables.
        %
        %  Then, a lower dimensional parameterization:
        %
        %  [ x; y] = Gz + h
        %
        %  is found with [A1 A2] h = b, [A1 A2] G = 0.
        %
        %
            
            function prgout = moveConstraints(prgout,prg,free)
                if ~isempty(prg.posCnst)
                    prgout = prgout.withPos(subs(prg.posCnst,prg.variables,free));
                end
            end
            
            
            function prgout = removeConic(prg)
                prgout = spotsdp(prg.name);
                [prgout,free] = prgout.newFree(length(prg.variables));
            
                if prg.numPos > 0
                    mtch = match(prg.variables,prg.posVariables);
                    prgout = prgout.withPos(free(mtch));
                end
                
                if prg.numLor > 0
                    error('Did not support Lorentz cone yet.');
                end
                
                prgout = moveConstraints(prgout,prg,free);
                prgout = prgout.withEqs(subs(prg.equations,prg.variables,free));
            end
            
            function prgout = removeEquality(prg)
            % Now resolve equality constraints.
                if length(prg.equations) == 0,
                    prgout = prg;
                    G = speye(prg.numFree);
                    h = sparse([],[],[],prg.numFree,1);
                    return;
                end
                
                prgout = spotsdp(prg.name);

                [A,b] = spot_decomp_linear(prg.equations,prg.variables);
            
                % TODO: Return to this setting to preserve sparsity.
                
                h = A\b;
                
                [Q,R] = qr(A');
                n = max(find(sum(abs(R),2)));
                G = Q(:,n+1:end); % New basis

                [prgout,z] = prgout.newFree(size(G,2));
                
                prgout = moveConstraints(prgout,prg,G*z+h);
            end
            
            prgout = removeConic(prg);
            prgout = removeEquality(prgout);
          
        end
    end
    

end